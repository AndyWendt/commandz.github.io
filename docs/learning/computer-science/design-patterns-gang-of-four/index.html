<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Patterns - Commandz.io</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <header>
        <nav>
            <a href="/" class="nav-logo">
                <img src="/images/cmdz.jpg" alt="Commandz.io Logo" />
            </a>
            <a href="/about">About</a>
            <a href="/posts">Blog</a>
            <a href="/learning">Learning</a>
            <a href="/snippets">Snippets</a>
        </nav>
    </header>

    <main>
        
<article class="content">
    <header class="content-header">
        <h1 class="title">Design Patterns</h1>
        
        <div class="metadata">
            <div class="primary-meta">
                
                <time datetime="2019-03-20T00:09:09.000Z">20 Mar 2019</time>
                

                

                
            </div>

            
            <div class="tags-container">
                
                <span class="tag">data structures</span>
                
                <span class="tag">design patterns</span>
                
                <span class="tag">architecture</span>
                
                <span class="tag">computer science</span>
                
                <span class="tag">learning</span>
                
            </div>
            
        </div>

        
        <div class="abstract">
            The seminal and definitive work on software design patterns
        </div>
        

        
        <div class="featured-image">
            <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">
                <img src="/images/books/design-patterns-gang-of-four.jpg" alt="Design Patterns">
            </a>
        </div>
        
    </header>

    <div class="content-body">
        <h3>Preface</h3>
<p>Design patterns describe simple and elegant solutions to specific problems in OOD which reflect untold refactoring and effort.  While they often take extra effort to implement, they are worth it given the increased flexibility and reusability that is gained.</p>
<h3>1. Introduction</h3>
<p>Expert designers don't solve every problem from first principles.  Design patterns make it easy to reuse successful design and architecture.</p>
<h4>1.1 What is a design pattern</h4>
<p>A pattern has four essential elements: name, a handle to describe a design problem; problem, which explains the problem and its context; solution, which explains the elements that make up the problem but doesn't proscribe an implementation; and consequences, any results or trade-offs that need to be considered for this pattern.</p>
<p>Design patterns describe OO designs.</p>
<h4>1.2 Design Patterns in Smalltalk MVC</h4>
<p>MVC helps to decouple views from models through the use of the Observer Pattern (293).  A change in the model can update any number of Views (pub/sub).  Views can be nested in MVC, and that is representative of the Composite (163) pattern which allows you to treat a group of objects as an individual object.</p>
<p>MVC allows you to change how an application responds to user input without changing the View, through swapping out the controller which is an example of the Strategy (315) pattern.</p>
<p>Other patterns MVC uses are Factory Method (107) (to pick the default controller) and Decorator (175) (to add scrolling to a view).</p>
<h4>1.5 Organizing Design Patterns</h4>
<p>Design pattern organization is broken up into purpose and scope.  Purpose describes what a pattern does: creational, structural, or behavioral.  Scope defines whether the pattern applies to classes or objects (i.e., to inheritance or composition/relationships).</p>
<p>See here for how scope affects the different purposes.</p>
<h4>1.6 How design patterns solve design problems</h4>
<h5>Finding Appropriate Objects</h5>
<p>An object encapsulates both data and procedures.  There are several design methodologies including finding names and verbs, determining collaboration and responsibilities, and modeling the real world.</p>
<p>Of note is that many classes have no real-world counterparts and a strict modeling approach won't reflect the realities of tomorrow nor allow enough flexibility for inevitable change.</p>
<p>Many of these objects are found when trying to make a design more flexible.</p>
<h5>Specifying Object Interfaces (13)</h5>
<p>Several basic OO terms are reviewed.</p>
<p>Dynamic and polymorphism discussed.  Polymorphism allows for substitutability, decouples objects, simplifies definitions, and lets them vary their relationships.</p>
<h5>Specifying Object Implementations (14)</h5>
<p>An object's implementation is defined by its class.  Instantiation, inheritance, abstract classes, and operations, concretions, and mixin classes discussed.</p>
<h5>Class vs. Interface Inheritance (16)</h5>
<p>A type only refers to an object's type.  An object supports the interface defined by the class.  Class inheritance defines an objects implementation/representation in terms of another object's implementation.</p>
<p>Interface inheritance describes when an object can be used in place of another.  Many languages don't make the distinction explicit wherein inheritance means both interface and implementation inheritance.  In these languages, people usually act as if subclasses were subtypes.</p>
<p>Chain of Responsibility (223) objects usually don't share a common implementation.  Composite (163) defines a common implementation.  Command (233), Observer (293), State (305), and Strategy (315) are often implemented with abstract classes that are pure interfaces.</p>
<h5>Programming to an Interface, not an Implementation (17)</h5>
<p>Class inheritance lets you define a new kind of object rapidly in terms of the old one, but it also lets you define families of objects with identical interfaces (polymorphism depends on it).</p>
<p>First principle of OOD:</p>
<blockquote>
<p>Program to an interface, not an implementation.</p>
</blockquote>
<p>Benefits:</p>
<ol>
<li>clients remain unaware of the objects they use</li>
<li>classes remain unaware of the classes they implement</li>
</ol>
<p>Don't declare variables to be instances of concrete classes.  Commit only to an interface defined by an abstract class.</p>
<h5>Putting Reuse Mechanisms to Work</h5>
<h6>Inheritance versus Composition</h6>
<p>The second principle of OOD:</p>
<blockquote>
<p>Favor object composition over class inheritance</p>
</blockquote>
<p>Class inheritance is a form of white-box reuse (OOD Designers often overuse inheritance) wherein the subclass knows the internals of the parent class (the services that it uses).  It is straightforward and easy to use, but that ease of use breaks encapsulation since the parent classes define part of the child classes representation.  You also can't swap out the parent's implementation at runtime (like you can with dependency injection and interfaces).</p>
<p>Object composition is defined dynamically at runtime (interfaces, dependency injection, creational patterns) and has the added benefit of not breaking encapsulation.  It keeps classes focused on one task and the communication thereof between objects inheritance and composition work together.  Composition designs are often more straightforward.</p>
<h6>Delegation (20)</h6>
<p>Delegation makes composition just as powerful for reuse as inheritance.  It allows you to compose behaviors at runtime by fulfilling the contracts it requires.  However, it is harder to understand dynamic, highly parameterized software.  Delegation is proper when it simplifies more than it complicates.  It works best when used with standard patterns.</p>
<h6>Inheritance versus Paramerterized Types (Genericsâ€”21)</h6>
<p>Parameterized types are essentially generics, and they give you another method to compose object behavior.  However, like inheritance, they cannot be changed at runtime.</p>
<h5>Relating Run-Time and Compile-Time Structures</h5>
<p>An OO program's runtime structure doesn't resemble its code structure.  Aggregation is where one object is responsible for another and thus are fewer and more permanent.  Acquaintances just know of another object, and it is much loser coupling.  Both of these are determined more by intent than language constructs.</p>
<h6>Designing for Change (24)</h6>
<blockquote>
<p>The key to maximizing reuse lies in anticipating new requirements and changes to existing requirements, and in designing your systems so that they can evolve accordingly.</p>
</blockquote>
<p>Unanticipated changes are invariably expensive.</p>
<p>Common causes of redesign and their patterns:</p>
<ul>
<li>Creating objects directly: Abstract Factory (87), Factory Method (107), Prototype (117)</li>
<li>Specific Operations Dependency: Command (233), Chain of Responsibility (223)</li>
<li>Dependency on an External Entity: Abstract Factory (87), Bridge (151)</li>
<li>Dependence on Specific Implementations: Abstract Factories (87), Bridge (151), Memento (283), Proxy (207)</li>
<li>Algorithmic dependency: Algorithms likely to change should be isolated. Builder (97), Iterator (257), Strategy (315), Template Method (325), Visitor (331).</li>
<li>Tight coupling: hard to reuse in isolation since they depend on each other.  Leads to monolithic systems since you can't change a class without understanding or changing many.  Loose coupling increases the portability of a class.  Abstract Factory (87), Bridge (151), Chain of Responsibility (223), Command (233), Facade (185), Mediator (273), Observer (293).</li>
<li>Extending Functionality by Subclassing: requires an in-depth understanding of the parent class but heavy use of composition can make a system hard to understand.  Bridge (151), Chain of Responsibility (223), Composite (163), Decorator (175), Observer (293), Strategy (315).</li>
<li>Inability to Alter Classes: library, package, etc.  Adapter (139), Decorator (175), Visitor (331).</li>
</ul>
<h6>Appllcation Programs (25)</h6>
<blockquote>
<p>Internal reuse ensures that you don't design and implement any more than you have to.</p>
</blockquote>
<p>Loose coupling increases object collaboration and extensibility.  Design patterns make an application more maintainable when used to limit dependencies and layer a system.</p>
<h6>Toolkits (packages &amp; libraries) (26)</h6>
<p>Composed of general purpose functionality that doesn't impose a particular design on your application.  Designing a package is harder than application design.</p>
<h6>Frameworks (26)</h6>
<p>Dictate the architecture of your application and, subsequently, emphasize design reuse over code reuse.  Frameworks are the hardest to design.</p>
<blockquote>
<p>Applications are dependent on the framework, and as such, they are particularly sensitive to changes in the framework interfaces.  Therefore, the application should only be loosely coupled to the framework.</p>
</blockquote>
<h4>1.7 How to Select a Design Pattern (28)</h4>
<p>Ways to select a Design Pattern:</p>
<ul>
<li>Consider how design patterns solve design problems</li>
<li>Scan intent sections</li>
<li>Study how patterns interrelate</li>
<li>Study patterns of like purpose</li>
<li>Examine a cause of redesign</li>
<li>Consider what should be variable in your design (encapsulate the concept that varies)</li>
</ul>
<h4>1.8 How to use a Design Pattern (29)</h4>
<p>Design patterns should not be applied indiscriminately.  The flexibility and variability are often gained by additional levels of indirection which often complicate a design needlessly.</p>
<blockquote>
<p>A design pattern should only be applied when the flexibility it affords is actually needed.</p>
</blockquote>
<h3>2.2 Dcoument Structure</h3>
<p>Recursive composition entails building increasingly complex elements out of simpler ones.  The Composite (163) pattern captures this in OO terms.</p>
<h3>2.3 Formatting (40) (Strategy)</h3>
<p>Discusses encapsulating the formatting algorithm.  The Open Closed Principle (OCP), dependency inversion principle (DIP), and Liskov substitution principle (LSP) as related to the formatting algorithm implied.  Strategy pattern discussed.</p>
<h3>2.4 Embellishing the User Interface (Decorator)</h3>
<p>Transparent enclosure combines the notions of single child/single component composition and compatible interfaces.</p>
<p>What it basically equates to is an inheritance hierarchy wherein subclasses reimplement operations, but calls the parents method, to not replace it.</p>
<p>This is essentially the Decorator (175) pattern.  It keeps clients free of embellishment code.  Embellishment refers to anything that adds responsibility to an object.</p>
<h3>2.5 Supporting Multiple Look and Feel Standards (Abstract Factory)</h3>
<p>Abstracting object creation assists with design goals in that it allows changing a look and feel at runtime.</p>
<p>An Abstract Factory (87) abstracts families of objects without instantiating the objects directly.  The key participants are factories and products.  Factories can be selected via something as simple as an if/else construct or something more complex such as a <a href="https://martinfowler.com/eaaCatalog/registry.html">Registry (480)</a>.  A Singleton (127) can be used to manage the instances (today a DI container can do the same thing better).</p>
<h3>2.6 Supporting Multiple Window Systems (Bridge &amp; Abstract Factory)</h3>
<p>Different Windowing systems (Mac, PC, Linux) change in different ways for different reasons.  Creating a single abstraction, based on an intersection of functionality at one extreme or a union of functionality at the other, creates a system that is either only as powerful as the least capable system or immense and incoherent.</p>
<p>To solve, you <strong>encapsulate the concept that varies</strong>, which in this case is the window implementation for the particular system.  The window implementation is an abstraction, possibly large but stable, that the various window variations use.  By hiding this behind an implementation class, you avoid polluting the window classes with window system dependencies.  The window base class constructor can use a window system factory to get the window implementation.  The window object interface matches the application programmers view of the world and makes it easier to work with.</p>
<p>The Bridge (151) pattern allows multiple class hierarchies to work together even as they evolve independently.  Its interface can be biased toward an intersection or union of functionality.  The boundary, created by a Bridge, creates a stable interface for systems that change often.  This allows a more programmer friendly interface to be created by other classes for general usage and also allow for application-specific business rules to use it.</p>
<p>The Bridge pattern could be used to isolate changes in multiple, unstable APIs that are called for the same reason.</p>
<h3>2.7 User Operations</h3>
<p>Functions are difficult to extend, and it's hard to reuse parts of them.  It's hard to associate state with a function.</p>
<p><strong>Encapsulate the concept that varies!</strong></p>

    </div>
</article>

<style>
    .content {
        max-width: 900px;
        margin: 0 auto;
        padding: 0 1rem;
    }

    .content-header {
        margin-bottom: 3rem;
    }

    .title {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        line-height: 1.2;
    }

    .metadata {
        margin: 1.5rem 0;
    }

    .primary-meta {
        color: #666;
        font-size: 1rem;
        margin-bottom: 1rem;
    }

    .separator {
        margin: 0 0.5rem;
        color: #ccc;
    }

    .tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
    }

    .tag {
        background-color: #f3f4f6;
        color: #4b5563;
        font-size: 0.875rem;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        display: inline-block;
        transition: all 0.2s ease;
    }

    .tag:hover {
        background-color: #e5e7eb;
    }

    .abstract {
        font-size: 1.25rem;
        color: #4b5563;
        margin: 2rem 0;
        line-height: 1.6;
        font-style: italic;
    }

    .featured-image {
        margin: 2rem auto;
        text-align: center;
        max-width: 700px;
    }

    .featured-image img {
        max-width: 100%;
        height: auto;
        border-radius: 12px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Specific image sizing based on image path */
    img[src*="/books/"] {
        max-width: 300px;
    }

    img[src*="/courses/"] {
        max-width: 500px;
    }

    img[src*="/videos/"] {
        max-width: 600px;
    }

    .content-body {
        font-size: 1.125rem;
        line-height: 1.75;
        color: #1a1a1a;
    }

    @media (max-width: 768px) {
        .title {
            font-size: 2rem;
        }

        .abstract {
            font-size: 1.125rem;
        }

        .featured-image {
            max-width: 100%;
        }
        
        img[src*="/books/"],
        img[src*="/courses/"],
        img[src*="/videos/"] {
            max-width: 100%;
            width: auto;
        }
    }
</style> 

    </main>

    <footer class="site-footer">
        <p>&copy; 2019 Commandz.io. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 