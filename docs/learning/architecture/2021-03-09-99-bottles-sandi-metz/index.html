<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>99 Bottles of OOP - Commandz.io</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <header>
        <nav>
            <a href="/" class="nav-logo">
                <img src="/images/cmdz.jpg" alt="Commandz.io Logo" />
            </a>
            <a href="/about">About</a>
            <a href="/posts">Blog</a>
            <a href="/learning">Learning</a>
            <a href="/snippets">Snippets</a>
        </nav>
    </header>

    <main>
        
<article class="content">
    <header class="content-header">
        <h1 class="title">99 Bottles of OOP</h1>
        
        <div class="metadata">
            <div class="primary-meta">
                
                <time datetime="2020-03-09T00:00:00.000Z">09 Mar 2020</time>
                

                
                <span class="separator">•</span>
                <span class="presenter">notes on work by Sandi Metz</span>
                

                
            </div>

            
            <div class="tags-container">
                
                <span class="tag">architecture</span>
                
                <span class="tag">object oriented</span>
                
                <span class="tag">computer science</span>
                
                <span class="tag">data structures</span>
                
                <span class="tag">design patterns</span>
                
                <span class="tag">learning</span>
                
            </div>
            
        </div>

        
        <div class="abstract">
            A practical guide to writing cost-effective, maintainable, and pleasing object-oriented code
        </div>
        

        
        <div class="featured-image">
            <a href="https://sandimetz.com/99bottles" target="_blank" rel="noopener">
                <img src="/images/99bottles.jpeg" alt="99 Bottles of OOP">
            </a>
        </div>
        
    </header>

    <div class="content-body">
        <h1>Things to Remember</h1>
<ul>
<li>&quot;This code places the burden upon the reader&quot; -&gt; forces you to create a mental map</li>
<li>&quot;interpolate duplicated logic inside strings&quot;</li>
<li>&quot;concepts hidden in the code that are not yet visible because they haven’t been isolated and named&quot;</li>
<li>&quot;duplicates both data and logic&quot;</li>
<li>&quot;concepts that it does not name&quot;</li>
<li>&quot;concise to the point of incomprehensibility while simultaneously retaining loads of duplication.&quot;</li>
<li>Goals: &quot;concrete enough to be understood while simultaneously being abstract enough to allow for change.&quot;
<ul>
<li>When do we reach that point?  a lot sooner... why? lack of concepts and the concepts are the ones that vary</li>
</ul>
</li>
</ul>
<ol>
<li>How difficult was it to write?</li>
<li>How hard is it to understand?
<ul>
<li>No concepts expressed.</li>
<li>Logic duplicated</li>
</ul>
</li>
<li>How expensive will it be to change?
<ul>
<li>have to change multiple lines etc</li>
</ul>
</li>
</ol>
<p>Problems with consistency, duplication, and naming.</p>
<p>it is incumbent upon you to accept the harder task and write simpler code.</p>
<h2>Naming / Understandability</h2>
<p>your efforts are for other readers</p>
<p>Write for understandability now. The very act of looking at a piece of code declares that you wish to understand it at this moment.</p>
<p>Code is easy to understand when it clearly reflects the problem it’s solving, and thus openly exposes that problem’s domain.</p>
<h3>Naming</h3>
<p>named the method after what it does right now. Unfortunately, when you name a method after its current implementation, you can never change that internal implementation without ruining the method name.</p>
<p>The tie-breaker here is that the &quot;name things at one higher level of abstraction&quot; rule applies more to methods than to classes.  while you should continue to name methods after what they mean, classes can be named after what they are.</p>
<p>the price you pay for poor names is relatively low [in the short term]. However, code is read many.  more times than it is written, and its ultimate cost is often very high and paid by someone else.</p>
<p>You should name methods not after what they do, but after what they mean, what they represent in the context of your domain.</p>
<ul>
<li>He named methods after what they did in our domain not after what they represent in the context of our domain</li>
</ul>
<p>If you were to ask your customer what X is in the context of the Y</p>
<ul>
<li>the word &quot;beverage&quot; is one level of abstraction higher than &quot;beer.&quot;</li>
</ul>
<p>Look for terms one level of abstraction higher -&gt; isolates from changes in implementation.</p>
<p>name methods after the concept they represent rather than how they currently behave.</p>
<p>perfect name for a concept is elusive:</p>
<ul>
<li>allot themselves five to ten minutes to ponder</li>
<li>instantly choose a meaningless name like foo or namethis</li>
<li>&quot;You’ll never know less than you know right now&quot;</li>
<li>Ask someone</li>
</ul>
<h3>Concepts</h3>
<p>The number of concepts, number of variants for the concept, the difference between the variants, and the algorithm for looping are distressingly obscure.</p>
<p>A lack of ability to identify concepts and break up functionality along conceptual lines.</p>
<h3>Differences</h3>
<p>How can we make the differences obvious?</p>
<h3>Clarity / Complexity</h3>
<p>Why are there so many levels of indirection needed?</p>
<p>while complexity is not forbidden, it is required to pay its own way.</p>
<p>priority is NOT brevity</p>
<h2>Coupling</h2>
<p>Didn't extract behavior along the lines of the concept.  It's a valid way to do things even in functional and OO.</p>
<ul>
<li>He coupled concepts -&gt; coupling concepts leads to things that change for different reasons being coupled together.</li>
<li>concepts are mixed together</li>
</ul>
<p>concepts are mixed together, conflated, such that their individual natures are obscured.</p>
<ul>
<li>The core of this problem is identifying the concepts (and naming the concepts) and isolating how they vary regardless of whether you choose a functional or OO style.</li>
</ul>
<h2>Premature Abstraction</h2>
<p>its author feared that the logic for selecting or invoking a template would someday need to change,</p>
<h2>Duplication</h2>
<p>The code is DRY, and DRYing out code should reduce costs. DRY promises that if you put a chunk of code into a method and then invoke that method instead of duplicating the code, you will save money later if the behavior of that chunk changes.</p>
<ul>
<li>The fault here, however, lies not with the DRY principle, but with the names of the methods. (beer being changed to koolaid)</li>
</ul>
<h1>1) Rediscovering Simplicity</h1>
<p>OO code is less concrete but more abstract—you’ve made it initially harder to understand in hopes that it will ultimately be easier to maintain.</p>
<p>OOD isn't free it just claims that it's benefits outweight its costs.  DRY isn't free either.</p>
<p>Abstractions -&gt; hard -&gt; easy to get wrong -&gt; tend to over-anticipate abstractions -&gt; should resist them until they absolutely insist upon being created</p>
<h2>1.1 Simplifying</h2>
<p>&quot;It must remain concrete enough to be understood while simultaneously being abstract enough to allow for change.&quot;</p>
<p>&quot;concise to the point of incomprehensibility while simultaneously retaining loads of duplication.&quot;</p>
<p>&quot;concepts that it does not name&quot;</p>
<p>&quot;duplicates both data and logic&quot;</p>
<p>&quot;Having multiple copies of the strings &quot;of beer&quot; and &quot;on the wall&quot; isn’t great, but at least string duplication is easy to see and understand.&quot;</p>
<p>&quot;Logic, however, is harder to comprehend than data, and duplicated logic is doubly so.&quot;</p>
<p>&quot;maximum confusion, you can interpolate duplicated logic inside strings, as does the verse method above.&quot;</p>
<p>Duplication of logic suggests that there are concepts hidden in the code that are not yet visible because they haven’t been isolated and named.  Each bit of logic serves some purpose, and it is up to you to construct a mental map of what these purposes might be.</p>
<p>This code would be easier to understand if it did not place that burden upon you, the intrepid reader</p>
<p>Referring to the act of invoking behavior as &quot;calling&quot; a method or function suggests (albeit mildly) that you know what that called code does.  &quot;sending a message&quot; leaves a bit more mental space between the sender’s intention and the receiver’s implementation.</p>
<p>identifying the code you’d like to extract and deciding on a method name. This, in turn, requires naming the concept,</p>
<p>Code is easy to understand when it clearly reflects the problem it’s solving, and thus openly exposes that problem’s domain.</p>
<p>Write for understandability now. The very act of looking at a piece of code declares that you wish to understand it at this moment.</p>
<ol>
<li>How many verse variants are there?</li>
<li>Which verses are most alike? In what way?</li>
<li>Which verses are most different, and in what way?</li>
<li>What is the rule to determine which verse comes next?</li>
</ol>
<p>The number of variants, the difference between the variants, and the algorithm for looping are distressingly obscure.</p>
<h2>1.1.2 Speculative Generality</h2>
<p>Verses 0, 1 and 2 are clearly different from 3-99, although it’s not obvious in what way.</p>
<p>Verses 0, 1 and 2 are clearly different from 3-99, although it’s not obvious in what way.</p>
<p>This choosing/rendering code is overly complicated, and while complexity is not forbidden, it is required to pay its own way. In this case, complexity does not.</p>
<p>its author feared that the logic for selecting or invoking a template would someday need to change,</p>
<p>(1.1.3 Concretely Abstract</p>
<p>Basically the methods are exactly the what a thing is potentially (&quot;goToTheStoreOrTakeOneDown()&quot;).<br>
While changing the code inside any individual method is cheap, in many cases, one simple change will cascade and force many other changes.</p>
<p>The code is DRY, and DRYing out code should reduce costs. DRY promises that if you put a chunk of code into a method and then invoke that method instead of duplicating the code, you will save money later if the behavior of that chunk changes.</p>
<p>The fault here, however, lies not with the DRY principle, but with the names of the methods.</p>
<p>If you were to ask your customer what &quot;beer&quot; is in the context of the &quot;99 Bottles&quot; song</p>
<h2>1.1.4 Shameless Green</h2>
<p>Shameless Green is clearly the best solution, yet almost no one writes it. It feels embarrassingly easy</p>
<p>if you pretend that this problem is a proxy for a real, production application, the proper course of action is not so clear.</p>
<p>One of the biggest challenges of design is knowing when to stop</p>
<h2>1.2 Shameless Green</h2>
<p>definitions generally describe how code looks when it’s done without providing any concrete guidance about how to get there.</p>
<blockquote>
<p>I like my code to be elegant and efficient. — Bjarne Stroustrup<br>
Clean code is ... full of crisp abstractions ... — Grady Booch<br>
Clean code was written by someone who cares. — Michael Feathers</p>
</blockquote>
<blockquote>
<p>Any pile of code can be made to<br>
work; good code not only works, but is also simple, understandable, expressive and changeable. -- Sandi Metz</p>
</blockquote>
<p>The attributes they use to describe good code are qualitative, not quantitative.</p>
<p>Since form follows function, good code can also be defined simply, and somewhat circularly, as that which provides the highest value for the lowest cost.</p>
<h2>1.3 Summary</h2>
<p>As programmers grow, they get better at solving challenging problems, and become comfortable with complexity. This higher level of comfort sometimes leads to the belief that complexity is inevitable, as if it’s the natural, inescapable state of all finished code. However, there’s something beyond complexity—a higher level of simplicity. Infinitely experienced programmers do not write infinitely complex code; they write code that’s blindingly simple.</p>
<p>Shameless Green--it is cheaper to manage temporary duplication than to recover from incorrect abstractions.  if nothing ever changes, the most cost-effective strategy is to deploy this code and walk away.</p>
<p>The Shameless Green solution strives for maximum understandability but is generally unconcerned with changeability.</p>
<h1>2</h1>
<h2>2.3 Removing Duplication</h2>
<p>While in the &quot;writing tests&quot; hat, you keep your eye on the big picture and work your way forward with the overall plan in mind.  When in the &quot;writing code&quot; hat, you pretend to know nothing other than the requirements specified by the tests at hand.</p>
<p>TDD requires that you pass tests by writing simple code.</p>
<p>The first part (lines 2-6) contains the conditional, and the second (lines 8-12) contains a template that could correctly generate many verses</p>
<p>you’ve separated the things that change from the things that remain the same,</p>
<p>As tests get more specific, code should become more generic. Code becomes more generic by becoming more abstract.</p>
<p>gets worse before it gets better.</p>
<p>With embedded conditionals, &quot;even if an abstraction lurks here, it certainly has not been named.&quot;  The concept of pluralization is a red herring</p>
<p>The fact that &quot;bottle&quot; is duplicated many times signals that there’s an underlying concept that has not yet been unearthed.</p>
<p>Making one look different will ultimately make it harder to see how all are the same.</p>
<p>Code like this pluralize method gets written when programmers take the DRY principle to extremes, as if they’re allergic to duplication.</p>
<p>Does the change I’m contemplating make the code harder to understand?<br>
What is the future cost of doing nothing now?<br>
When will the future arrive, or how soon will I get more information?</p>
<p>Writing Shameless Green means optimizing for understandability, not changeability, and patiently tolerating duplication if doing so will help reveal the underlying abstraction.</p>
<p>You should complete the entire horizontal path before indulging in any vertical digressions.</p>
<p>Use of if / else if implies that each subsequent condition varies in a meaningful way.</p>
<p>This implementation reveals some important concepts in the domain.</p>
<p>This lack of indirection is a direct result of the dearth of abstractions.</p>
<p>Some duplication is tolerable during the search for Shameless Green. However, not all duplication is helpful,</p>
<p>Duplication is useful when it supplies independent, specific examples of a general concept that you don’t yet understand.</p>
<p>new code duplicates an example that already exists</p>
<p>duplicating this already-existing code masks the true responsibility of verses</p>
<p>Developing the habit of writing just enough code to pass the tests forces you to write better tests.</p>
<p>It’s best to save Obvious Implementation for very small leaps.</p>
<p>Knowledge that one object has about another creates a dependency. Dependencies tie objects together, exacerbating the cost of change. Your goal as a message sender is to incur a limited number of dependencies, and your obligation as a method provider is to inflict few.</p>
<p>The distinction between intention and implementation [...] allows you to understand a computation first in essence and later, if necessary, in detail. -- Kent Beck</p>
<p>A great deal of this pain originates with tests that are tied too closely to code.</p>
<p>write tests that confirm what your code does without any knowledge of how your code does it.</p>
<p>Tests are not the place for abstractions—they are the place for concretions.</p>
<p>If you insist on reducing duplication by adding logic to your tests, this logic by necessity must mirror the logic in your code.</p>
<p>Testing, done well, speeds development and lowers costs.</p>
<p>TDD can prevent costly guesses, but only if you commit to writing code in small steps.</p>
<p>Tests can make it safe and easy to refactor, but only if they are carefully de-coupled from the current code.</p>
<h1>3.) Unearthing Concepts</h1>
<p>The Shameless Green solution values understandability, straight-forwardness and efficiency, with little regard for changeability. It contains duplication, and is unapologetic about leaning in the procedural direction.</p>
<p>Conditionals are the bane of OO</p>
<p>The &quot;open&quot; principle says that you should not conflate the process of moving code around, of refactoring, with the act of adding new features. You should instead separate these two operations.</p>
<p>there is no direct connection between removing the duplication, and succeeding in making the code open to the six-pack requirement. That, however, is the beauty of this technique. You don’t have to know how to solve the whole problem in advance.</p>
<p>safe refactoring relies upon tests.</p>
<p>never change tests during a refactoring.</p>
<p>Tests that make assertions about how things are done, rather than what actually happens, are the prime contributors to this predicament.</p>
<p>Flocking Rules</p>
<ol>
<li>Select the things that are most alike.</li>
<li>Find the smallest difference between them.</li>
<li>Make the simplest change to remove that difference:<br>
a. parse the new code<br>
b. parse and execute it<br>
c. parse, execute and use its result<br>
d. delete unused code</li>
</ol>
<p>Making small changes means you get very precise error messages when something goes wrong, so it’s useful to know how to work at this level of granularity.</p>
<ol>
<li>Alignment - Steer towards the average heading of neighbors</li>
<li>Separation - Don’t get too close to a neighbor</li>
<li>Cohesion - Steer towards the average position of the flock</li>
</ol>
<p>sameness is easier to identify, difference is more useful because it has more meaning. DRYing out sameness has some value, but DRYing out difference has more.</p>
<blockquote>
<p>The focus here is encapsulating the concept that varies, a theme of many design patterns</p>
</blockquote>
<p>a systematic application of the rules of refactoring converts difference to sameness, decomposing a problem into its constituent parts.</p>
<p>You don’t have to identify the underlying abstractions in advance of refactoring. If you merely write the code dictated by the rules, the abstractions will follow.</p>
<p>solving easy problems, through a magical alchemy of code, sometimes transmutes hard problems into easy ones. It is common to find that hard problems are hard only because the easy ones have not yet been solved.</p>
<p>Within the context of the song, &quot;bottle/bottles&quot; does not represent pluralization.</p>
<p>The general rule is that the name of a thing should be one level of abstraction higher than the thing itself.</p>
<p>no change breaks the tests, the code can be deployed to production at any intermediate point.</p>
<p>&quot;Gradual Cutover Refactoring,&quot; a strategy for keeping the code in a releasable state by gradually switching over a small number of pieces at a time.</p>
<p>The act of adding a new branch to the conditional while executing only the previously existing code is a mini-example of the Open/Closed Principle. You can think of this change as making the container method open to a new requirement</p>
<p>The small amount of time lost to making incremental changes is more than recouped by avoiding lengthy and frustrating debugging sessions. This style of coding is not only fast, it’s also stress-free.</p>
<p>Real refactoring is comfortingly predictable, and saves brainpower for more thought-provoking challenges.</p>
<p>refactor the existing code to be open to the new requirement, next, add the new code.</p>
<p>Sometimes the first step, refactoring to openness, requires such a large leap that it is not obvious how to achieve it. In that case, be guided by code smells.</p>
<p>Making existing code open to a new requirement often requires identifying and naming abstractions.</p>
<h1>4) Practicing Horizontal Refactoring</h1>
<p>The act of substituting a variable for an explicit number is so minor that it doesn’t adequately reflect the enormity of the underlying idea, but step back and consider what just happened. Replacing differing concrete values with a reference to a common variable changes difference into sameness.</p>
<p>If all verse variants are alike in an underlying, more abstract, way, then &quot;it&quot; and &quot;one&quot; must represent a smaller abstraction within that larger one.</p>
<p>perfect name for a concept is elusive:</p>
<p>allot themselves five to ten minutes to ponder<br>
instantly choose a meaningless name like foo or namethis<br>
&quot;You’ll never know less than you know right now&quot;<br>
Ask someone</p>
<p>Do not take this as a general license to think far ahead. While you are allowed to use common sense, it’s usually best to stay horizontal and concentrate on the current goal. When creating an abstraction, first describe its responsibility as you understand it at this moment</p>
<p>All of these refactorings extract a method. Because this is done in very small steps, the extracted methods start out simple and then gradually become more complicated. One of the complications is that each method changes to take a parameter.</p>
<p>Notice the similarities in the above methods. Each has a single responsibility. They are identical in shape. All take the same argument. Each contains a conditional and that conditional tests the argument against a specific value; it checks to see if the argument is equal to something, as opposed to greater or less than something.  These methods are incredibly consistent, and this did not happen by accident—it’s a direct result of the refactoring rules</p>
<p>(no more vs No more) These words are one thing, and whether they need to be capitalized is quite another.</p>
<p>The above change follows the strategy of gradually making things more alike in hopes that it will then become clear how to make them identical.</p>
<p>The idea of reducing the number of dependencies imposed upon message senders by requiring that receivers return trustworthy objects is a generalization of the Liskov Substitution Principle.  Liskov, in straightforward language, requires that objects be what they promise they are.  Liskov prohibits you from doing anything that would force the sender of a message to test the returned result in order to know how to behave.</p>
<p>Successor does feel like the right name for the current concept, but using it requires that you define successor to mean following rather than higher.</p>
<p>The concept is so subtle most programmers don’t notice it, and yet it simply appears if you follow this simple set of rules.</p>
<p>abstractions tell you where your code relies upon an idea.</p>
<p>according to the metrics, it’s worse<br>
turn one conditional into many, while simultaneously adding 55% more code.</p>
<p>An improvement has been made that is invisible to static analysis tools.</p>
<p>Power of the Flocking Rules to uncover sophisticated concepts: You don’t have to understand the entire problem in order to find and express the correct abstractions—you merely apply these rules, repeatedly, and abstractions will naturally appear.</p>
<h1>5) RESP</h1>
<p>the current incarnation is less amenable to this requirement than was Shameless Green.  The truth about refactoring is that it sometimes makes things worse</p>
<p>The refactoring recipes don’t promise to result in code that better expresses the problem—they merely make it easy to create that new expression, and just as easy to revert it.</p>
<p>Proper refactoring allows you to explore a problem domain safely.</p>
<p>continue to be guided by code smells</p>
<ol>
<li>Do any methods have the same shape?</li>
<li>Do any methods take an argument of the same name?</li>
<li>Do arguments of the same name always mean the same thing?</li>
<li>If you were to make some methods private, which ones would they be?</li>
<li>If you were going to break this class into two pieces, where’s the dividing line?<br>
Do the tests in the conditionals have anything in common?<br>
How many branches do the conditionals have?<br>
Do the methods contain any code other than the conditional?<br>
Does each method depend more on the argument that got passed, or on the class as a whole?</li>
</ol>
<p>non-essential variation disguises a common shape</p>
<p>Superfluous difference raises the cost of reading code, and increases the difficulty of future refactorings.</p>
<p>the argument they receive is a bottle number rather than a verse number. Thus, the verse method and the flocked five methods use the same argument name to represent different concepts.</p>
<p>Having multiple methods that take the same argument is a code smell.</p>
<p>the term &quot;same&quot; means same concept, not identical name.</p>
<p>the same concept might go by several different names</p>
<p>different concepts might hide behind a single name</p>
<p>naming mistakes make it harder to notice underlying code smells</p>
<p>Testing for equality has several benefits over the alternatives. Most obviously, it narrows the range of things that meet the condition.</p>
<p>a deeply non-object-oriented pattern: the flocked five methods take an argument, examine it, and then supply behavior for it.</p>
<p>injecting a dependency ($number), but that dependency is too impaired to supply the needed behavior.</p>
<p>know about $number, but it’s also forced to understand what the specific values of $number mean,</p>
<p>OO mindset, and that mindset is deeply suspicious of conditionals.</p>
<p>when you see a conditional, the hairs on your neck should stand up. Its very presence ought to offend your sensibilities. You should feel entitled to send messages to</p>
<p>objects, and look for a way to write code that allows you to do so. The above pattern means that objects are missing, and suggests that subsequent refactorings are needed to reveal them.</p>
<p>There is a place for conditionals in OO.</p>
<p>Manageable OO applications consist of pools of small objects that collaborate to accomplish tasks.</p>
<p>big difference between a conditional that selects the correct object and one that supplies behavior.  The first is acceptable and generally unavoidable. The second suggests that you are missing objects in your domain.</p>
<p>What does it mean to be &quot;open&quot;?</p>
<p>Each item above acts like a vote, and these votes combine to point to Primitive Obsession as the dominant code smell.</p>
<p>Obsessing on a primitive results in code that passes built-in types around, and supplies behavior for them.  The cure for Primitive Obsession is to create a new class to use in place of the primitive. For this operation, the refactoring recipe is Extract Class.</p>
<p>This new class does not represent a kind of bottle: it represents a kind of number. The distinction may seem subtle, but the divide between these two concepts is chasmic. A bottle is a thing, while a number is an idea. It’s easy to imagine creating objects that stand in for things, but the power of OO is that it lets you model ideas.</p>
<p>Model-able ideas often lie dormant in the interactions between other objects.</p>
<p>The tie-breaker here is that the &quot;name things at one higher level of abstraction&quot; rule applies more to methods than to classes.  while you should continue to name methods after what they mean, classes can be named after what they are.</p>
<p>remember to save the code after every change, and to run the tests after every save</p>
<p>The methods weren’t moved—they were duplicated, so nothing about Bottle has yet been changed</p>
<p>the example above starts with Fowler’s final step, and combines all of the method moves within a single change. [Fowler's refactoring was done that way so that it could be done without tests]</p>
<p>Learning the art of transforming code one line at a time, while keeping the tests passing at every point, lets you undertake enormous refactorings piecemeal.  This small problem is a good place to practice this technique, in preparation for later tackling bigger ones.</p>
<p>If you adhere to a recipe and tests start failing, it’s likely that there’s something about the problem that you don’t yet understand.</p>
<p>A great benefit of these refactoring techniques is that you can accomplish quite a bit while thinking very little.</p>
<p>The real world is pervaded by this idea—what exists, will change.</p>
<p>Because they are easy to reason about, immutable objects are also easy to test. Objects that change need tests for the affected behavior.</p>
<p>The benefits of immutability are so great that, if it were free, you’d choose it every time.  The ongoing costs of immutability are therefore mostly in the creation of new objects,</p>
<p>Given this, the best programming strategy is to write the simplest code possible and measure its performance once you’re done.</p>
<p>Your goal is to optimize for ease of understanding while maintaining performance that’s fast enough. Don’t sacrifice readability in advance of having solid performance data. The first solution to any problem should avoid caching, use immutable objects, and treat object creation as free. This results in speedy development of simple code, which leaves plenty of time to identify and correct the real performance problems.</p>
<p>(new BottleNumber($number))-&gt;quantity();</p>
<p>And just like that, you’ve added caching plus mutation.  You’ll find that the changes needed to do this add complexity. This complexity may cost more than the benefit gained by faster performance.</p>
<p>You have every right to expect any method named successor to return an object that implements the same API as the receiver, but alas, this successor method does not.</p>
<p>You have every right to expect any method named successor to return an object that implements the same API as the receiver, but alas, this successor method does not.<br>
This inconsistency is another violation of the generalized Liskov Substitution Principle.</p>
<p>This current refactoring is almost complete, and it is often better to finish horizontal refactorings before undertaking vertical tangents. You could veer from the path and fix the Liskov violation, but in the spirit of completing the current thought before undertaking a new task, stay the course.</p>
<h1>6) Achieving Openness</h1>
<p>This increasing isolation of the concepts that need to vary is an indication that the code is moving in the right direction.</p>
<p>Above, quantity and container appear together in three different places (lines 8, 10, and 12). The duplication of this pairing gives off a whiff of the Data Clump code smell.</p>
<p>Having a clump of data usually means you are missing a concept.  When a clump gets sent as a set of parameters, the method that receives the clump can easily become polluted with clump management logic.  some or all of this management logic will inevitably get duplicated in several places. Not only is it a pain to maintain this duplication, but over time the logic might accidentally diverge, introducing errors and confusing everyone involved.</p>
<p>usually removed by extracting a class.</p>
<p>The current __toString maximizes the effect of removing the Data Clump in verse</p>
<p>The verse method is getting simpler, but it still has more than one responsibility. This problem is reflected by the very structure of the code—the above method contains a blank line.  Programmers add blank lines to signify changes of topic. The presence of multiple topics suggests the existence of multiple responsibilities, which makes code harder to understand when reading, and easier to harm when changing.</p>
<p>These conditionals characterize the class, and make Switch Statement the most identifiable code smell.</p>
<p>The Replace Conditional with State/Strategy recipe removes conditionals by dispersing their branches into new, smaller objects, one of which is later selected and plugged back in at runtime. This recipe results in a code arrangement known as composition.</p>
<p>The Replace Conditional with Polymorphism recipe removes conditionals by creating one class to hold the defaults of the conditionals (the false branches), and adding subclasses for each specialization (the true branches of the various conditions). It then chooses one of these new objects to plug back in at runtime. This recipe solves the conditional problem using inheritance.</p>
<p>They know what’s right before they do it.  Or at least they do, sometimes. They also know that they don’t know everything.</p>
<p>they engage in careful, precise, reproducible, and reversible coding experiments.  Practice builds intuition. Do it enough, and you’ll seem magical too.</p>
<p>polymorphism refers to the idea of having many different kinds of objects that respond to the same message.</p>
<p>Senders don’t care what receivers are; instead, they depend on what receivers do.</p>
<p>Polymorphism, by definition, involves more than one kind of object, so changing from a procedural to a polymorphic code arrangement will increase the overall number of classes.  as conditionals disappear from BottleNumber, new dependencies will arise.</p>
<p>Obsessions are usually cured by extracting a class, and if you suspect that class extraction is called for here, you are correct.</p>
<p>The specific logic for 0 needs to be isolated in a class of its own, as does the logic for 1.</p>
<p>Removing the conditionals without breaking the tests requires a process that carefully and systematically moves the code from each true branch into a new object, rather than willy-nilly deleting it. The specific logic for 0 needs to be isolated in a class of its own, as does the logic for 1. Also, as these new classes come into existence, some additional code will have to be written to choose the correct class based on the value of number.</p>
<p>As previously stated, this recipe uses inheritance. Modern object-oriented programming is biased towards preferring composition over inheritance. However, this bias shouldn’t be taken to mean that the use of inheritance is banned.</p>
<p>When several classes play a common role, some code, somewhere, must know how to choose the right role-playing class for any specific contingency. This choosing very often involves a conditional, which should exist in one and only one place.</p>
<p>When a factory exists for a role, the factory has sole responsibility for creating objects to play that role. The factory’s purpose is to isolate the names of the concrete classes, and to hide the logic needed to choose the correct one.</p>
<p>The bottleNumberFor method inserts a level of indirection between the desire for a BottleNumber and its creation.</p>
<p>The above code works, but it’s not perfect. The problem is that the branches of the conditional combine things that differ (BottleNumber0 and BottleNumber) with things that remain the same (return new ...($number)). This conflation forces the reader to study the code to discern the difference.</p>
<p>return new $className($number);</p>
<p>The nice thing about this version is that it isolates the things that vary, which highlights the difference between the conditions.</p>
<p>When you invoke the factory to get a bottle number, you don’t need to know the class of the returned object.  This willful ignorance of type is fundamental to object-oriented programming.</p>
<p>It insulates code that calls a factory from changes of implementation within that factory. By refusing to be aware of the classes of the objects with which you interact, you grant others the freedom to alter your code’s behavior without editing its source.</p>
<p>The conditional above may be giving you a sense of deja vu. It’s reminiscent of, although not quite identical to, the switch statement from the original Shameless Green solution.</p>
<p>If introducing polymorphism improved the code, this new version ought to tell an accurate and easily understood story about the domain.</p>
<p>The successor methods return a result so unexpected that it’s perilously close to being an outright lie.</p>
<p>Liskov violations are insidious, and over time cause increasing harm. As your application evolves, successor might get sent from many places. Each place will have to know that successor returns a number, and must also know how to convert that number back into a bottle number. This interconnected web of duplicated knowledge binds every sender of successor to its current implementation, which inflicts dependencies that make code resistant to change.</p>
<p>The root of the problem is that a new type (BottleNumber) was introduced, but its successor method continued to return the old type (int).</p>
<p>The current predicament stands in for the real-world problem of needing to change the type returned by a polymorphic method that has many implementors and many senders.</p>
<p>For problems of this size, you might be successful at changing everything at once, but real life typically involves larger problems that require many more changes and present a much greater challenge.</p>
<p>the best choice is to make the factory a static function on an existing class.</p>
<p>there are two good reasons to simplify its name.<br>
First, changing the name avoids the &quot;echo chamber&quot; effect. BottleNumber-&gt;bottleNumberFor is both redundant and overly specific. It suffers from the same ailment as the beer method in Chapter 1. This name is tightly coupled to the current context, and tight coupling makes code resistant to change.  if you someday decide to rename the BottleNumber class, you’ll have to change this method name too, or forever be misled.</p>
<p>for is a generic request that works fine as the name of any factory.  When factory-ish objects polymorphically implement for, you can send this message without regard for the receiver’s type. Polymorphism preserves the option of constructing applications where the factories themselves are substitutable.</p>
<p>First, changing the name avoids the &quot;echo chamber&quot; effect. BottleNumber-&gt;bottleNumberFor is both redundant and overly specific.</p>
<p>This name is tightly coupled to the current context, and tight coupling makes code resistant to change.</p>
<p>Second, and more abstractly, for supports polymorphism.  __toString() allows for polymorophism because all classess in php support it.  If each class used a unique name or qualified their string casting method by their type then you would have to know the type of the object in order to cast it to a string</p>
<p>It’s much simpler to have stringifiable objects polymorphically implement an identically named method,</p>
<p>the trick to moving forward using one-undo (more on this later) changes is to temporarily alter the factory to tolerate both kinds of input.</p>
<p>[if you have types in place for params, you can still remove them and or change the signature of the method and get some  of the benefits of polymorphism]</p>
<p>Correcting the Liskov violation is important because object-oriented programming, especially in dynamically-typed languages like PHP, relies on explicit trust in the implicit contracts between objects.</p>
<p>Trustworthy objects are a joy to work with because they always behave as you expect.</p>
<p>untrustworthy objects require senders of messages to know too much.</p>
<p>When your application has code that needs knowledge of the internals of other objects in order to correctly interact with them (as did successor above), changes to those other objects might break your code.</p>
<p>If you have to check the type of an object in order to know what message to send, you’re forced into a conditional that lists every concrete class with which you’re willing to collaborate.</p>
<p>Checking to see if an object responds to a message rather than checking that object’s type may reduce the size of this conditional, but it doesn’t ameliorate the problem.</p>
<p>All of the above are symptoms of an inability to trust other objects, and failures of trustworthiness are, at least by the current generous interpretation of the principle, Liskov violations.</p>
<p>Objects made promises that they did not keep. In every case, the underlying cause is an insufficient use of polymorphism.</p>
<p>Consider the meaning of __toString versus that of quantity and container. The latter two methods reflect fundamental concepts in this domain.</p>
<p>Consider the meaning of __toString versus that of quantity and container. The latter two methods reflect fundamental concepts in this domain.</p>
<h1>7) Manufacturing Intelligence</h1>
<p>The difference in the number of branches, although highly visible, is merely an artifact of the specific domain of the &quot;99 Bottles of Beer&quot; song. Having explained that difference away, another yet remains, and this one has significantly more meaning.<br>
The Shameless Green verse method contains a conditional that:</p>
<ol>
<li>understands why you might switch (case 0, for example), and</li>
<li>knows the behavior needed for this case (&quot;No more bottles . . .&quot;). The factory for method:</li>
<li>is similar in that it also understands the reasons for switching (again, case 0, etc) but 2. differs in that it knows the name of the class that supplies the behavior for the case.</li>
</ol>
<p>Factories don’t know what to do: instead, they know how to choose who does.</p>
<p>difference between a conditional that supplies behavior and a conditional that selects an object</p>
<p>The power of polymorphism is that these role-playing objects are interchangeable from the message sender’s point of view.</p>
<p>The message- sending object thinks of its collaborator as a player of a role rather than a kind of a type.  They know what their collaborators do, but refuse to be aware of how they do it.</p>
<p>A system comprised of message senders who collaborate with role-playing objects can be extremely tolerant of unexpected change.</p>
<p>this system works only if message senders really do treat collaborators as if they’re interchangeable</p>
<p>If message senders are to be immune from side-effects when adding or removing role-players, these senders can’t know things that are unique to specific variants.</p>
<p>Message senders aren’t allowed to know the names of the concrete variant classes, nor may they know the logic needed to choose between them.</p>
<p>A factory’s responsibility is to manufacture the right object for a given role.</p>
<p>This choosing usually involves a conditional, and putting this conditional in a factory allows you to isolate it to a single place in your code.</p>
<p>Thus, factories are where conditionals go to die. Isolating conditionals in factories loosens the coupling between collaborating objects, which lowers the cost of change.</p>
<p>Factories vary along these dimensions:</p>
<ol>
<li>The factory can be open to new variants or closed.</li>
<li>The logic that chooses a variant can be owned by the factory or by the variant.</li>
<li>The factory can be responsible for knowing/figuring out which classes are eligible to be manufactured or the variants can volunteer themselves.</li>
</ol>
<p>Downsides of meta programmed factories</p>
<p>harder to understand<br>
no longer explicitly referenced in the source code.<br>
need to have covering tests<br>
gnores bottle number classes whose names do not follow the convention.<br>
Again, need good tests</p>
<p>A downside of the switch is that, If new classes get added regularly, this is annoying and expensive.</p>
<p>The first step towards an open factory that both centralizes knowledge and supports arbitrary class names is to rearrange the code to increase the isolation of the names. You can do this by replacing the switch statement with a key/value lookup</p>
<p>the data has been separated from the algorithm</p>
<p>The benefit of this separation is that you can now think of the driving data [finding the class] as an entity in itself, separate from the choosing algorithm.</p>
<p>Notice that in the switch version, the colors alternate, while in the key/value version, like colors group more closely together. These groupings say something about the code.</p>
<p>When the colors change constantly it means that the code changes topics a lot.  Code that is more object-oriented tends to group like things together, with fewer changes of topic.</p>
<p>On procedures<br>
The upside of procedures is that simple ones (short and without conditionals) are easy to understand. The downside is that complex ones (long and with many conditionals) are costly to change.</p>
<p>The most efficient, expedient way to fulfill a new requirement may be to write a simple, unglamorous procedure, but if this procedure needs to change it should be converted into object- oriented code.</p>
<p>Procedural code can save you money when used to create small, isolated features that never need to change, but this style of coding will break the bank if used on large, shared features that are core to your domain.</p>
<p>OO asks you to break code up into small, cohesive pieces. The benefit of having smaller pieces is that each individual piece, relative to its procedural analog, is easier to understand and change.</p>
<p>The straightforwardness of simple procedures can make them seem attractive, and indeed, they’re fine as long as nothing ever changes. However, if your code needs to adapt and grow, it’s worth paying the toll charged by OOP.</p>
<p>Choosing logic in factories</p>
<p>The logic needed to select the right class might be long, complex, and more closely related to the class being chosen than to the factory itself. If the choosing logic changes in lockstep with code that lives in the class being chosen, then the choosing logic belongs in that class, not in the factory.</p>
<p>each choose-able object implements its own method to determine if it should be chosen</p>
<p>This factory disperses the choosing logic into the things chosen. In this example, that logic is so simple that this technique is excessive, but in some situations, choosing will involve lots of code, and that code will change in lockstep with the class being chosen.</p>
<p>several issues. First, it’s closed. Each time a new class is added you must update the list on 5-8.  BottleNumber must always be the last class on the list.  it’s possible that more than one handles methods would return true</p>
<p>If your choosing logic is more closely related to the class being chosen than to the factory, the choosing logic should be co-located in that class.</p>
<p>Self-registering candidates</p>
<p>f you would like the factory to simply continue working when new candidates appear, you have two basic options.</p>
<ol>
<li>The factory could dynamically figure out which classes belong on its list, or</li>
<li>classes who want to be on the list could explicitly ask the factory to put them there. registry</li>
</ol>
<p>inheritance vs class name dependency<br>
Choosing between depending on a class name versus depending on inheritance means placing a bet on which dependency is more stable.<br>
[what about using composition and an interface?]</p>
<h1>8) Developing a Programming Aesthetic</h1>
<p>Here’s the process used to create the verse template role:</p>
<ol>
<li>Identify the code you want to vary.</li>
<li>Name the underlying concept.</li>
<li>Extract the identified code into its own class.</li>
<li>Inject this new role-playing object back into the object from which it was extracted. 5. Forward messages from the original class to the injected object.</li>
</ol>
<p>Isolate the behavior you want to vary.  One of the most fundamental concepts in OO is to isolate the behavior you want to vary.</p>
<p>Isolating variants often requires that you invert dependencies, and an excellent technique for inverting dependencies is to inject them.</p>
<p>Law of Demeter<br>
The code may produce the correct output at this moment, but will not age well.  These messages tightly couple Foo to a chain of different objects, all of which must be available.  interferes with your ability to use Foo in new and unexpected contexts.  Nothing here stands alone—this group of objects acts like a single thing and any use requires every piece.</p>
<p>Tests serve many purposes, one of which is to reveal how easy it is to reuse code. Tightly-coupled code is difficult to test. Tightly-coupled objects require adding lots of context, all of which must be provided in order to run any test.</p>
<p>An object that’s hard to test is attempting to warn you that it will be difficult to reuse.</p>
<p>The Law of Demeter says that from within a method, messages should be sent only to:<br>
objects that are passed in as arguments to the method<br>
objects that are directly available to $this</p>
<p>It’s not the number of object operators that matter, but the kind of object returned by each message.</p>
<p>The Law of Demeter effectively restricts the list of other objects to which an object may send a message.</p>
<p>an object may talk to its neighbors but not to its neighbor’s neighbors.</p>
<p>Curing Demeter<br>
introducing message forwarding,<br>
The code in each method above obeys the Law of Demeter by sending messages only to direct collaborators.<br>
The trick to honoring the Law while simultaneously avoiding encoding the names of existing objects into the names of the forwarding messages is to think about design from the message senders point of view.</p>
<p>Now that Foo is talking only to a direct collaborator instead poking around in distant objects, it more easily tolerates unexpected change.</p>
<p>you should inject the thing you want to talk to</p>
<p>If you want something, just ask for it. If the receiver doesn’t know how to comply, teach it..   loosen coupling by designing a conversation that embodies what the message sender wants.</p>
<p>This static function does two things. First, it uses forwarding to eradicate the extra hop and resolve the Demeter violation.</p>
<p>Test setup seems likely to be painful. Pain in testing is a sign of a rigid application and an indication that there’s something wrong with the design.</p>
<p>Be extremely biased towards fixing violations. The overall cost of dealing with each transgression as it occurs is guaranteed to be less than the ultimate cost of repairing the few that spiral out of control after infecting your code for several years.</p>
<p>Classes vs Instances</p>
<p>Despite the fact that earlier in this chapter, classes were treated as &quot;just another object&quot; when deciding if new contributed to a Demeter violation, classes are different from instances in the most fundamental object-oriented way. In instances, common behavior combines with differing data to create objects that collaborate to form your application.</p>
<p>Putting domain behavior in a static function rather than in an instance method places a bet that this domain concept will never involve data that varies.  This bet makes sense only if the value of not typing n e and w today is greater than the future cost of converting all the static functions to instance methods should you find that data needs to vary.</p>
<p>always create instances of objects.  Part of your programming aesthetic is to reflexively put domain behavior on instances.</p>
<p>If someone else knows enough to provide _lyrics with the right $number, surely that someone can provide the right BottleNumber instead.</p>
<p>Well-designed object-oriented applications consist of loosely-coupled objects that rely on polymorphism to vary behavior. Injecting dependencies loosens coupling.  Polymorphism isolates variant behavior into sets of interchangeable objects that look the same from the outside but behave differently on the inside.</p>
<p>Separating Object Creation from Object Use</p>
<p>systems where object creation begins to separate from object use.  Object creation gets pushed more towards the edges, towards the outside, and the objects themselves interact more towards the middle, or the inside.</p>
<p>resist giving instance methods knowledge of concrete class names, and<br>
seek opportunities to move the object creation towards the edges of the application.</p>
<p>These are guidelines, not hard and fast rules, so you can allow yourself some leeway.  especially true in cases like this where the hard-coded reference is to a factory, so the coupling is already loose.</p>
<p>The one line rule</p>
<p>it’s worth practicing how to fix these names with smaller changes. Before doing so, however, it’s finally time to amend the one-line rule.</p>
<p>Instead of being restricted to one-line changes, refactoring permits one-undo changes.<br>
one-undo rule allows you to use the find/replace feature of your text editor to make many changes at once.</p>
<p>Put domain behavior on instances.<br>
Be averse to allowing instance methods to know the names of constants.<br>
Seek to depend on injected abstractions rather than hard-coded concretions.<br>
Push object creation to the edges, expecting objects to be created in one place and used in another.<br>
Avoid Demeter violations, using the temptation to create them as a spur to search for deeper abstractions.</p>
<p>Complying with these precepts will frequently increase the amount of code and add levels of indirection, at least in the short term.</p>

    </div>
</article>

<style>
    .content {
        max-width: 900px;
        margin: 0 auto;
        padding: 0 1rem;
    }

    .content-header {
        margin-bottom: 3rem;
    }

    .title {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        line-height: 1.2;
    }

    .metadata {
        margin: 1.5rem 0;
    }

    .primary-meta {
        color: #666;
        font-size: 1rem;
        margin-bottom: 1rem;
    }

    .separator {
        margin: 0 0.5rem;
        color: #ccc;
    }

    .tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
    }

    .tag {
        background-color: #f3f4f6;
        color: #4b5563;
        font-size: 0.875rem;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        display: inline-block;
        transition: all 0.2s ease;
    }

    .tag:hover {
        background-color: #e5e7eb;
    }

    .abstract {
        font-size: 1.25rem;
        color: #4b5563;
        margin: 2rem 0;
        line-height: 1.6;
        font-style: italic;
    }

    .featured-image {
        margin: 2rem auto;
        text-align: center;
        max-width: 700px;
    }

    .featured-image img {
        max-width: 100%;
        height: auto;
        border-radius: 12px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Specific image sizing based on image path */
    img[src*="/books/"] {
        max-width: 300px;
    }

    img[src*="/courses/"] {
        max-width: 500px;
    }

    img[src*="/videos/"] {
        max-width: 600px;
    }

    .content-body {
        font-size: 1.125rem;
        line-height: 1.75;
        color: #1a1a1a;
    }

    @media (max-width: 768px) {
        .title {
            font-size: 2rem;
        }

        .abstract {
            font-size: 1.125rem;
        }

        .featured-image {
            max-width: 100%;
        }
        
        img[src*="/books/"],
        img[src*="/courses/"],
        img[src*="/videos/"] {
            max-width: 100%;
            width: auto;
        }
    }
</style> 

    </main>

    <footer class="site-footer">
        <p>&copy; 2020 Commandz.io. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 