<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Design by Construx - Commandz.io</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <header>
        <nav>
            <a href="/" class="nav-logo">
                <img src="/images/cmdz.jpg" alt="Commandz.io Logo" />
            </a>
            <a href="/about">About</a>
            <a href="/posts">Blog</a>
            <a href="/learning">Learning</a>
            <a href="/snippets">Snippets</a>
        </nav>
    </header>

    <main>
        
<article class="content">
    <header class="content-header">
        <h1 class="title">Software Design by Construx</h1>
        
        <div class="metadata">
            <div class="primary-meta">
                
                <time datetime="2019-04-28T00:00:00.000Z">28 Apr 2019</time>
                

                
                <span class="separator">•</span>
                <span class="presenter">by Steve Tockey</span>
                

                
            </div>

            
            <div class="tags-container">
                
                <span class="tag">architecture</span>
                
                <span class="tag">object oriented</span>
                
                <span class="tag">computer science</span>
                
                <span class="tag">data structures</span>
                
                <span class="tag">design patterns</span>
                
                <span class="tag">learning</span>
                
            </div>
            
        </div>

        
        <div class="abstract">
            Notes on the construx course on software design
        </div>
        

        
        <div class="featured-image">
            <a href="https://construx.vueocity.com/portal/SDB1" target="_blank" rel="noopener">
                <img src="/images/courses/architecture/construx-software-design.png" alt="Software Design by Construx">
            </a>
        </div>
        
    </header>

    <div class="content-body">
        <h1>Introduction</h1>
<h2>Software Productivity Studies</h2>
<h3>Code Wars</h3>
<p>Referenced study by Tom Demarco and Timothy Lister that showed that fewer lines of code equaled less time required to complete regardless of the programming language.  There was an order of magnitude of difference between the largest and smallest solution for a given language.</p>
<p><img src="/images/courses/architecture/construx-software-design/lines-of-code-and-time-to-complete.png" alt="Lines of code and time to complete"></p>
<h3>Managing the Real Leverage in Software Productivity and Quality</h3>
<p>A study by Dr. Bill Curtis entitled, “Managing the Real Leverage in Software Productivity and Quality”  ad developers examine the same program in which there was a single error.  The study asked how long did it take each developer to find the error and fix it?</p>
<p>The results were astounding (all correct answers).  The ratio was 1 to 22 from the shortest to longest but even more interesting was their additional finding:</p>
<blockquote>
<p>“The correlation between years of experience and performance was essentially zero.  We found that the breadth of different programming experiences was the best predictor of performance.  … we virtually always found a correlation between performance and the number of languages (and paradigms) known.</p>
</blockquote>
<h3>The Net Negative Producing Programmer (Gordon Schulmeyer)</h3>
<p><a href="http://wiki.c2.com/?NetNegativeProducingProgrammer">C2 Wiki Article</a><br>
<a href="http://pyxisinc.com/NNPP_Article.pdf">PDF of the article</a></p>
<blockquote>
<p>We've known since the early '60s but have never come to grips with the implications that there are net negative producing programmers (NNPPs) on almost all projects, who insert enough spoilage to exceed the value of their production.<br>
Taking a poor performer off the team can often be more productive than adding a good one.</p>
</blockquote>
<p>But it gets better:</p>
<blockquote>
<p>In a team of ten, expect as many as three people to have a defect<br>
rate high enough to make them NNPPs. With a normal distribution of<br>
skills, the probability that there is not even one NNPP out of ten is<br>
virtually nil.</p>
</blockquote>
<p>And better:</p>
<blockquote>
<p>If you are unfortunate enough to work on a high-defect<br>
project (density of from thirty to sixty defects per thousand lines of<br>
executable code), then fully half of your team may be NNPPs.</p>
</blockquote>
<p>At least 20% of developers are NNPPs.  Correlates with the Demarco and Lister test.</p>
<h2>What is Design?</h2>
<h3>Defining the term</h3>
<p>The flow from requirements to test</p>
<p>Requirements -&gt; Design -&gt; Construction -&gt; Test</p>
<ul>
<li>Requirements are decisions made by someone else</li>
<li>Design is made up of decisions that developers make</li>
<li>Construction and design are different views of the same thing (there isn't a boundary)</li>
</ul>
<blockquote>
<p>Software Design is a description of the software's internal structure that will serve as a basis for its construction</p>
</blockquote>
<p>Identify the significant elements of that internal structure.  Explain the important relationships between those elements. Provide sufficient detail to construct those elements.</p>
<h3>Design as a complexity management tool</h3>
<p>Why projects get in trouble: number one reason is bad requirements. Number two is poor project management. Number three is project complexity.  One and two are largely outside of the control of the developers.  Three is where we should focus our efforts.</p>
<ul>
<li><strong>Essential vs accidental complexity</strong>
<ul>
<li>there's problem space essential complexity and there's not much you can do to simplify that</li>
<li>accidental complexity is in the solution space</li>
</ul>
</li>
</ul>
<p>Accidental complexity comes in two different forms: necessary and unnecessary.  Necessary: doing something to meet performance or scalability requirements.  Unnecessary: doing something because a technique is intersting (Resume driven development).</p>
<p><strong>The goal:</strong>  minimize the amount of essential and necessary accidental complexity and get rid of unnecessary accidental complexity (refactoring).</p>
<p>Design is a complexity management tool.</p>
<h3>Design as a communication tool</h3>
<ul>
<li>Analysis and validation of proposed designs</li>
<li>Evaluation of design tradeoffs</li>
<li>Design as the basis for actual construction</li>
<li>Design as a resource for unit, integration, and component testing</li>
</ul>
<p>There's no such thing as self-documenting code. Code will only ever tell you what it does, not what it was intended to do.  Does the code &quot;have to&quot; look this way or does it just &quot;happen to&quot; look this way.</p>
<p>Design docs should emphasize <em>why</em> rather than <em>how</em>.</p>
<h3>Critical design ideas</h3>
<blockquote>
<p>In a typical software budget, 80% of the budget is spent on maintaining existing code.<br>
Decreasing maintenance costs is much more powerful than decreasing development costs.</p>
</blockquote>
<p>Software can kill people because of dumb design decisions.  Prototyping is very useful for exploring and testing various design ideas.</p>
<blockquote>
<p>Some design is better than no design, but the best is the enemy of the good.</p>
</blockquote>
<p>At some point you just need to shoot the engineer and go into production.</p>
<blockquote>
<p>Design is almost always an evolutionary process.</p>
</blockquote>
<blockquote>
<p>Good design leads to efficiency and effectiveness of both the code and the project of creating the code</p>
</blockquote>
<h2>Measuring Design Complexity</h2>
<p>If you can measure it you can't manage it.</p>
<p>These are heuristics.</p>
<h3>Cyclomatic Complexity</h3>
<p>The number of pathways through a section of code plus one. Count the decision points.  Most control statements add 1 complexity except for <code>else</code> and <code>default</code> which doesn't since there is no new decision.</p>
<p>[Schroeder 99]</p>
<p>11% of the codebase were responsible 42% of the codebase. As cyclomatic complexity goes up then defect density goes up with it.  Tabs v. spaces, curly brace placement, etc doesn't matter in comparison to complexity.  They're cosmetic.</p>
<p>No excuse for cyclomatic complexity of 15 or greater.  10 to 14 we have to have a discussion. 1 to 9 is good.</p>
<ul>
<li>Green zone: up to 9</li>
<li>Yellow zone: 10 to 14</li>
<li>Red zone: &gt;= 15</li>
</ul>
<blockquote>
<p>The correlation of cyclomatic complexity to defects is strongest at the function (method on a class) level.  Weak at the class level and gone at the package level.  There, more lines implies a proportionally higher number of defects.</p>
</blockquote>
<h3>Depth of Decision Nesting</h3>
<p>Deeply nested code is more complex even if the cyclomatic complexity is the same since there are dependencies between decisions.</p>
<p>Starts at one with the opening curly brace and whenever you open/close a decision you plus/minus.</p>
<ul>
<li>Green zone: up to decision nesting of 4.</li>
<li>Yellow zone: up to 5 or 6</li>
<li>Red zone: 7 or greater</li>
</ul>
<h3>Number of Parameters</h3>
<p><em>Building Maintainable Software: Ten Guidelines for Future-Proof Code</em>.</p>
<p>Control interface complexity by limiting the number of parameters to 4.</p>
<ul>
<li>Green zone: up to 4</li>
<li>Yellow zone: 5 or 6</li>
<li>Red zone: 7 or more</li>
</ul>
<h3>Fan Out</h3>
<p>Number of unique calls to other functions (including recursion).</p>
<p><code>(Fan-out number)^2 / 10</code>  has the best correlation to defect density.</p>
<ul>
<li>Green zone: up to 6</li>
<li>Yellow zone: 7 to 9</li>
<li>Red zone: &gt;= 10</li>
</ul>
<h3>Local vs. Global Complexity (the interplay of complexity metrics)</h3>
<p>Few functions equals greater cyclomatic complexity and the inverse is true.</p>
<ul>
<li>Global complexity metrics are: Number of parameters and fan out</li>
<li>Local complexity metrics are: cyclomatic complexity and depth of decision nesting</li>
</ul>
<blockquote>
<p>Designs with high cyclomatic complexity and high depth of decision nesting are too locally complex.</p>
<p>Designs with a high degree of fan out and a high number of parameters are too globally complex</p>
</blockquote>
<blockquote>
<p>You can trade local complexity for global complexity and the inverse</p>
</blockquote>
<p>Put limits on global and local complexity.</p>
<p>Fan-in: no correlation between fan-in and defection density.  It is a measure of reuse rather than complexity.</p>
<h2>Fundemental Design Principles</h2>
<h3>Syntax vs. Semantics</h3>
<ul>
<li><strong>Syntax:</strong> about structure
<ul>
<li>e.g. measuring design complexity using the above algorithms</li>
<li>can be automated</li>
<li>compiler is a ruthless master of</li>
</ul>
</li>
<li><strong>Semantics:</strong> about meaning
<ul>
<li>what the code means</li>
<li>can't be automated today</li>
<li>Syntactically correct but semantically meaningless</li>
</ul>
</li>
</ul>
<p>Bug is a horrible word.  Use defects.</p>
<blockquote>
<p>Defects are semantic inconsistencies: a difference between the semantics the code has versus the semantics the code should have.</p>
</blockquote>
<p>Because syntax is automatible, semantics is even more important.</p>
<h3>Principle: Use Abstraction</h3>
<blockquote>
<p>The principle of ignoring those aspects of a subject that are not relevant to the current purpose in order to concentrate solely on those that are.<br>
—Oxford 97</p>
</blockquote>
<p>Abstraction is permission to ignore.  Abstraction is THE number one complexity management tool.</p>
<p>From 1952:</p>
<blockquote>
<p>When a program has been made from a set of subroutines, the breakdown of the code is more complete than it otherwise would be.  This allows the coder to concentrate on one section of a program at a time without the overall detailed program continually intruding.<br>
—Wheeler 52</p>
</blockquote>
<p>Abstraction at the cost of performance has always been a point of discussion.  Better hardware performance has nullified the performance arguments.</p>
<p>In most interviews, the interviewers spend most of their time asking questions about a specific language.  Steve Tockey said that you shouldn't spend time on that but on asking questions about abstraction such as &quot;what is different between these X items.&quot;  How many different ways you can abstract.</p>
<blockquote>
<p>Those who are good at abstracting write the smallest, cleanest code that covers the problem space.  They're the best coders.  The people that are bad at abstracting write bad code.</p>
</blockquote>
<p>A programming language is a learnable skill.  Why waste time asking about it?  Abstraction is more difficult to learn and therefore usually needs to be baked in.</p>
<h3>Principle: Encapsulate Design Decisions</h3>
<p>Abstraction and encapsulation are related concepts.</p>
<ul>
<li>Abstraction is permission to ignore</li>
<li>Encapsulation hides the details from you altogether</li>
</ul>
<blockquote>
<p>Large programs that use encapsulation effectively are easier to modify—by a factor of 4—than programs that don't.  Encapsulation benefits are both technical and financial for an organization.</p>
</blockquote>
<p>It has indisputably proven its worth especially in fast-changing environments.  It's important to multiple paradigms including structured and OO.</p>
<h3>Required for Encapsulation: Design by Contract</h3>
<p>Functions need to be understoon—and specified—in terms of a contract.</p>
<ul>
<li>
<p>what it requires beforehand</p>
</li>
<li>
<p>what it guarantees afterward</p>
</li>
<li>
<p>Put contracts into the code</p>
</li>
<li>
<p>Semantic mismatch: the calling programmer has to match the semantic of the called section of code.  Semantic mismatch: semantic implemented in the code is not the semantic that the calling programmer assumed.</p>
</li>
</ul>
<h4>Elements of a contract</h4>
<blockquote>
<p>Without design by contract, there can be no encapsulation.  Violations of encapsulation commonly break code.</p>
</blockquote>
<h5>Requires</h5>
<p>Constraints:</p>
<ul>
<li>on input parameters</li>
<li>on state</li>
</ul>
<h5>Guarantees</h5>
<ul>
<li>constraints on output parameters</li>
<li>constraints on state</li>
<li>errors/exceptions</li>
<li>performance limits</li>
</ul>
<p>Do Not include elements already enforced by the language.  It is over and above what the compiler enforces.</p>
<h4>Activity: Design by contract</h4>
<blockquote>
<p>All semantic decisions need to be communicated by the programmer who implements to the programmers who are going to utilize the stack.  Communicate through the contract.</p>
</blockquote>
<p>Program to and not through an interface.  All you <em>should</em> need is the contract.  Some contractural changes are safe while others need to be negotiated.</p>
<p>Many defects are essentially contract violations or differing semantic interpretations of an API.  By only a very little work (&lt;3% overhead) whole classes of defects are avoided by managing code to the contract.</p>
<p>Manage the semantics at the interface.</p>
<h3>Principles: Maximize Cohesion, Minimize Coupling</h3>
<p>The overall process of software development is decomposition followed by recomposition.  All decompositions are not equal.</p>
<p>Cohesion and coupling help you assess different decompositions and choose from among them.</p>
<p>Cohesion and coupling apply at the method level—methods should be highly cohesive/loosely coupled.  The principles also apply to classes, packages, and systems.</p>
<blockquote>
<p>Cohesion and coupling are pervasive properties that <strong>should apply at all levels of the decomposition</strong>.</p>
</blockquote>
<p>Cohesion and coupling also apply at the method level: add blank lines to visually decouple code groups that are coehesive wholes.</p>
<h4>Cohesion</h4>
<ul>
<li>Cohesion: indivisibility of a given part.  To what extent do pieces of the whole solve a complete problem that's part of the whole?</li>
</ul>
<p><img src="/images/courses/architecture/construx-software-design/cohesion.png" alt="Cohesion"></p>
<p>Count the number of cohesion violations.</p>
<p>An example: using a function <code>bool isLanguageInstalled(int languageCode, bool deleteIfNotTrue)</code> to both check if the language is installed and delete if the second parameter is false and the language is found (delete operation returns false).  This is a semantic violation.</p>
<h4>Coupling</h4>
<blockquote>
<p>Do not connect things that have no business being connected</p>
</blockquote>
<ul>
<li>What is the decomposition represented by the software?</li>
<li>Is it highly cohesive, or can the cohesion be improved?</li>
<li>Is it loosely coupled, or can the coupling be improved?</li>
</ul>
<h5>Law of Demeter: Principle of Least Knowledge</h5>
<blockquote>
<p>Method M of object O may only invoke methods of:</p>
<ul>
<li>O itself</li>
<li>O's direct component objects</li>
<li>M's paremeters</li>
<li>Objects created or instantiated within M</li>
</ul>
</blockquote>
<p>Avoid invoking methods of objects returned by other methods:</p>
<p><code>a.b().c()</code> breaks the law while <code>a.b()</code> does not.</p>
<p>DON'T: <code>aCustomer.ordersList(1).orderLines(1).isMedium().sellingPrice()</code></p>
<ul>
<li>customer shouldn't be aware of order lines or media in order to get the selling price.  Too tightly coupled</li>
</ul>
<h5>Loosely coupled</h5>
<p>If things do need to be connected, make the connection as loose as possible.</p>
<h3>Principle: Design to Invariants</h3>
<p>What are the requirements in common between all possible instances of a family of objects?</p>
<p>Base class contains the common functionality.</p>
<p>In what ways are the possible instances different?</p>
<p>Requirements that will remain relevant as long as the product's life cycle are invariants--make those part of the product platform.</p>
<h3>Principle: Design for Change</h3>
<p>Design in a way that those changes (invariants) are isolated from all of the standard stuff.</p>
<p>Base class contains the common functionality.</p>
<p>Use architectural layering to hide communication protocol variability (REST, SOA, etc).  Design patterns hide some important variation behind an abstract interface: adapter, bridge, strategy, factory method, abstract factory, template method, iterator, decorator, proxy, etc</p>
<p>If the requirement will change multiple times during the product's life cycle then you should design for change.</p>
<ul>
<li>How much does it cost now to build the simplest possible thing that could work?</li>
<li>How much will it cost later to make the product do more than the simplest possible thing?</li>
<li>How much does it cost now to build something that's expandable in the future?</li>
</ul>
<h4>Strategy: Delay the Bindig of Values to Implementation</h4>
<p>Attempt to delay the bindings.  TurboTax example.</p>
<ul>
<li>Named constants instead of magic numbers</li>
<li>Configuration/preferences/registry files</li>
<li>Dependency injection</li>
<li>Inversion of control</li>
<li>Data-driven design</li>
<li>Self-configuration</li>
</ul>
<h4>Strategies</h4>
<h5>Commonalities</h5>
<p>Basic set of job control states and events shouldn't change.</p>
<h5>Variabilities</h5>
<ul>
<li>Add a self-test on startup</li>
<li>Priority queueing</li>
<li>Cancel jobs while they're still in the queue</li>
<li>Enable an idle state</li>
</ul>
<h3>Principle: Avoid Premature Optimization</h3>
<blockquote>
<p>More computing sins are committed in the name of efficiency (withtou necessarily achieving it) than for any other single reason, including blind stupidity.<br>
-- W.A. Wulf</p>
</blockquote>
<blockquote>
<p>We should forget about small effiecies, say about 97% of the time: premature optimization is the root of all evil.<br>
--Donald Knuth</p>
</blockquote>
<blockquote>
<p>Jackson's Rules of Optimization:</p>
</blockquote>
<ul>
<li>Rule 1: Don't do it</li>
<li>Rule 2 (for experts only): don't do it yet--that is, not until you have a perfectly clear and unoptimized solution.</li>
</ul>
<blockquote>
<p>--M.A. Jackson</p>
</blockquote>
<h3>Principle: Fisher's Fundamental Theorem</h3>

    </div>
</article>

<style>
    .content {
        max-width: 900px;
        margin: 0 auto;
        padding: 0 1rem;
    }

    .content-header {
        margin-bottom: 3rem;
    }

    .title {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        line-height: 1.2;
    }

    .metadata {
        margin: 1.5rem 0;
    }

    .primary-meta {
        color: #666;
        font-size: 1rem;
        margin-bottom: 1rem;
    }

    .separator {
        margin: 0 0.5rem;
        color: #ccc;
    }

    .tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
    }

    .tag {
        background-color: #f3f4f6;
        color: #4b5563;
        font-size: 0.875rem;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        display: inline-block;
        transition: all 0.2s ease;
    }

    .tag:hover {
        background-color: #e5e7eb;
    }

    .abstract {
        font-size: 1.25rem;
        color: #4b5563;
        margin: 2rem 0;
        line-height: 1.6;
        font-style: italic;
    }

    .featured-image {
        margin: 2rem auto;
        text-align: center;
        max-width: 700px;
    }

    .featured-image img {
        max-width: 100%;
        height: auto;
        border-radius: 12px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Specific image sizing based on image path */
    img[src*="/books/"] {
        max-width: 300px;
    }

    img[src*="/courses/"] {
        max-width: 500px;
    }

    img[src*="/videos/"] {
        max-width: 600px;
    }

    .content-body {
        font-size: 1.125rem;
        line-height: 1.75;
        color: #1a1a1a;
    }

    @media (max-width: 768px) {
        .title {
            font-size: 2rem;
        }

        .abstract {
            font-size: 1.125rem;
        }

        .featured-image {
            max-width: 100%;
        }
        
        img[src*="/books/"],
        img[src*="/courses/"],
        img[src*="/videos/"] {
            max-width: 100%;
            width: auto;
        }
    }
</style> 
    </main>

    <footer class="site-footer">
        <p>&copy; 2019 Commandz.io. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 